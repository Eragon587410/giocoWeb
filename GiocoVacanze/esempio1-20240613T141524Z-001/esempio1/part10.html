<!doctype html> 
<html lang="en"> 
<head> 
    <meta charset="UTF-8" />
    <title>Making your first Phaser 3 Game - Part 10</title>
    <script src="//cdn.jsdelivr.net/npm/phaser@3.11.0/dist/phaser.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script type="text/javascript">

var config = {
    type: Phaser.AUTO,
    width: 1200,
    height: 600,
    physics: {
        default: 'arcade',
        arcade: {
            gravity: { y: 300 },
            debug: false
        }
    },
    scene: {
        preload: preload,
        create: create,
        update: update
    }
};
var nemicoMorto = false;
var isFiringEnemy = false;
var ascensoreX;
var morte = false;
var player;
var stars;
var rKey;
var bombs;
var granate = 12;
var granata;
var shields;
var proiettili;
var ascensori;
var platforms;
var cursors;
var isGranatingGo = false;
var score = 0;
var gameOver = false;
var scoreText;
var ammoText;
var lives = 3;
var fireRate = 500;
var ultimoSparo = -fireRate;
var ultimoSparo_enemy = -fireRate;
var isFiring = false;
var posizione = false;
var isGranating = false;
var isGranatingGo = false;;
var ascensore;
var fermi;
var fermo;
var atterrato = false;
var collisione = false;
var shiftKey;
var ammo;
var isReloading = false;
var gKey;
var enemy;

var game = new Phaser.Game(config);

function preload ()
{
    this.load.image('sky', 'assets/sky.png');
    this.load.spritesheet('grenade', 'assets/explosion.png', {frameWidth: 128, frameHeight: 128});
    this.load.image('game', 'assets/game.png');
    this.load.image('ground', 'assets/platform.png');
    this.load.image('star', 'assets/star.png');
    this.load.image('bomb', 'assets/bomb.png');
    this.load.image('shield', 'assets/live.png');
    this.load.image('proiettile', 'assets/proiettile.png');
    this.load.spritesheet('dude', 'assets/cazzone.png', { frameWidth: 128, frameHeight: 128 });
    this.load.spritesheet('enemy', 'assets/cazzone.png', { frameWidth: 128, frameHeight: 128 });
}

function create ()
{
    //  A simple background for our game
    this.add.image(400, 300, 'sky');
    this.add.image(1200, 300, 'sky');

    //  The platforms group contains the ground and the 2 ledges we can jump on
    platforms = this.physics.add.staticGroup();
    ascensori = this.physics.add.group();
    fermi = this.physics.add.staticGroup();

    //  Here we create the ground.
    //  Scale it to fit the width of the game (the original sprite is 400x32 in size)
    platforms.create(400, 568, 'ground').setScale(2).refreshBody();
    //platforms.create(800, 568, 'ground').setScale(2).refreshBody();
    platforms.create(1000, 584, 'ground');
    ascensore = ascensori.create(1400, 500, 'ground');
    ascensore.setCollideWorldBounds(true);
    ascensore.body.setAllowGravity(false);
    fermo = fermi.create(184, 336, 'ground').setAngle(90).refreshBody();
    fermo.setSize(32, 400);
    fermo.setOffset(-32, 0);
    fermo.disableBody(true, true);
    fermo = fermi.create(616, 336, 'ground').setAngle(90).refreshBody();
    fermo.setSize(32, 400);
    fermo.setOffset(-32, 0);
    fermo.disableBody(true, true);
    ascensore.setTint(0xff0000);
    

    ammo = 6;
    shiftKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SHIFT);
    rKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);
    gKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.G);

    boundsCollider = this.physics.add.sprite(0, 0, null);
    boundsCollider.setSize(this.physics.world.bounds.width, 1); // Imposta la larghezza uguale a quella del mondo
    boundsCollider.setOrigin(0, 0);
    var graphics = this.add.graphics();
    graphics.fillStyle(0xffffff); // Colore del triangolo (bianco)

// Definisci i vertici del triangolo (esempio per un triangolo equilatero)
    var trianglePoints = [
        new Phaser.Geom.Point(100, 300), // Coordinata vertice 1
        new Phaser.Geom.Point(300, 300), // Coordinata vertice 2
        new Phaser.Geom.Point(200, 200)  // Coordinata vertice 3
    ];

    var triangle = new Phaser.Geom.Triangle(trianglePoints[0], trianglePoints[1], trianglePoints[2]);
    graphics.fillTriangleShape(triangle);
    graphics.closePath();

    var triangleCollider = this.add.zone(trianglePoints[0].x, trianglePoints[0].y).setSize(200, 100);
    this.physics.add.existing(triangleCollider);

// Assegna il collider al triangolo
    //triangleCollider.body.setTriangle(0, 0, 300 - 100, 300 - 300, 200 - 100, 200 - 300);


// Aggiungi il corpo fisico al triangolo
//this.physics.add.existing(triangolo);

// Configura il corpo fisico del triangolo come poligono con i vertici definiti
//triangolo.body.setPolygon(verticiTriangolo);

    //  Now let's create some ledges
    //platforms.create(600, 400, 'ground');
    //platforms.create(50, 250, 'ground');
    //platforms.create(750, 220, 'ground');

    // The player and its settings
    player = this.physics.add.sprite(100, 400, 'dude');
    enemy = this.physics.add.sprite(500, 400, 'enemy');

    //  Player physics properties. Give the little guy a slight bounce.
    player.setBounce(0);
    player.setCollideWorldBounds(true);
    player.setSize(40, 68);
    player.setOffset(40, 60);

    enemy.setBounce(0);
    enemy.setCollideWorldBounds(true);
    enemy.setSize(40, 68);
    enemy.setOffset(40, 60);

    

    //  Our player animations, turning, walking left and walking right.
    this.anims.create({
        key: 'left',
        frames: this.anims.generateFrameNumbers('dude', { start: 7, end: 13 }),
        frameRate: 10,
        repeat: -1
    
    });

    this.anims.create({
        key: 'fire',
        frames: this.anims.generateFrameNumbers('dude', { start: 14, end: 17 }),
        frameRate: 10,
        repeat: -1
    
    });
    this.anims.create({
        key: 'fire_enemy',
        frames: this.anims.generateFrameNumbers('enemy', { start: 14, end: 17 }),
        frameRate: 10,
        repeat: -1
    
    });

    this.anims.create({
        key: 'idle',
        frames: this.anims.generateFrameNumbers('dude', { start: 0, end: 6 }),
        frameRate: 20,
        repeat: -1
    });
    this.anims.create({
        key: 'idle_enemy',
        frames: this.anims.generateFrameNumbers('enemy', { start: 0, end: 6 }),
        frameRate: 20,
        repeat: -1
    });
    this.anims.create({
        key: 'granate_anim',
        frames: this.anims.generateFrameNumbers('grenade', { start: 0, end: 8 }),
        frameRate: 9,
        repeat: -1
    });
    this.anims.create({
            key: 'stay',
            frames: [ { key: 'dude', frame: 24 } ],
            frameRate: 10
    });

    this.anims.create({
        key: 'right',
        frames: this.anims.generateFrameNumbers('dude', { start: 7, end: 13 }),
        frameRate: 10,
        repeat: -1
    });

    this.anims.create({
        key: 'right_enemy',
        frames: this.anims.generateFrameNumbers('enemy', { start: 7, end: 13 }),
        frameRate: 10,
        repeat: -1
    });
    this.anims.create({
        key: 'run',
        frames: this.anims.generateFrameNumbers('dude', { start: 25, end: 32 }),
        frameRate: 10,
        repeat: -1
    });
    this.anims.create({
        key: 'reload',
        frames: this.anims.generateFrameNumbers('dude', { start: 33, end: 45 }),
        frameRate: 10,
        repeat: -1
    });
    this.anims.create({
        key: 'grenade',
        frames: this.anims.generateFrameNumbers('dude', { start: 46, end: 54 }),
        frameRate: 10,
        repeat: -1
    });
    this.anims.create({
        key: 'death',
        frames: this.anims.generateFrameNumbers('dude', { start: 18, end: 24 }),
        frameRate: 10,
        repeat: -1
    });
    this.anims.create({
        key: 'death_enemy',
        frames: this.anims.generateFrameNumbers('enemy', { start: 18, end: 24 }),
        frameRate: 10,
        repeat: -1
    });
    

    //  Input Events
    cursors = this.input.keyboard.createCursorKeys();

    //  Some stars to collect, 12 in total, evenly spaced 70 pixels apart along the x axis
    stars = this.physics.add.group({
        key: 'star',
        repeat: 11,
        setXY: { x: 12, y: 0, stepX: 70 }
    });

    stars.children.iterate(function (child) {

        //  Give each star a slightly different bounce
        //child.setBounceY(Phaser.Math.FloatBetween(0.4, 0.8));

    });

    bombs = this.physics.add.group();
    shields = this.physics.add.group();
    proiettili = this.physics.add.group();
    proiettili_enemy = this.physics.add.group();

    granata = this.physics.add.sprite(player.x+20, player.y-50, 'grenade');
    granata.setAllowGravity = true;
    granata.setCollideWorldBounds(true);
    granata.disableBody(true, true);

    var x = (player.x < 400) ? Phaser.Math.Between(0, 800) : Phaser.Math.Between(0, 400);

    var shield = shields.create(x, 16, 'shield');
    
    //  The score
    scoreText = this.add.text(19, 16, 'score: 0', { fontSize: '32px', fill: '#000' });
    livesText = this.add.text(16, 60, 'lives: '+ lives, { fontSize: '32px', fill: '#000' });
    ammoText = this.add.text(16, 104, 'Munizioni: ' + ammo, { fontSize: '32px', fill: '#000' });

    
    //  Collide the player and the stars with the platforms
    this.physics.add.collider(player, platforms);
    this.physics.add.collider(enemy, platforms);
    this.physics.add.collider(fermi,ascensori);
    this.physics.add.collider(stars, platforms);
    this.physics.add.collider(bombs, platforms);
    this.physics.add.collider(shields, platforms);
    this.physics.add.collider(proiettili, bombs);
    this.physics.add.collider(ascensori, platforms, setVariabile, null, this);
    this.physics.add.collider(player, ascensori, ascensoreFunziona, null, this);
    this.physics.add.collider(proiettili, fermi);
    this.physics.add.collider(proiettili, this.physics.world.bounds, collisionCallback, null, this);
    this.physics.add.collider(proiettili, enemy, dannoNemico, null, this);

    
    ascensoreX = ascensore.x;

    //  Checks to see if the player overlaps with any of the stars, if he does call the collectStar function
    this.physics.add.overlap(player, stars, collectStar, null, this);

    this.physics.add.collider(player, bombs, hitBomb, null, this);
    this.physics.add.collider(player, shields, collectLives, null, this);

    
}
function collisionCallback(){
    proiettile.disableBody();
    console.log("Il giocatore ha colpito il bordo della finestra!");
}
function update ()
{
    var time = this.time.now;
    if (gameOver && !morte)
    {
        
        player.anims.play('death', true);
        player.setVelocityX(0);
        this.time.delayedCall(player.anims.currentAnim.duration, () => {
            platforms.create(400, 300, 'game');
            player.disableBody(true, true);
            morte = true;
            return;
            
            
            
        });
        
    } else if (!gameOver){
        if (distanzaPlayerEnemy()<200 && ((player.body.x < enemy.body.x && enemy.flipX) || (player.body.x > enemy.body.x && !enemy.flipX)) && !nemicoMorto){
            if ((time - ultimoSparo_enemy) > fireRate && !isFiringEnemy){
                    enemy.setVelocityX(0);
                    isFiringEnemy = true;
                    enemy.anims.play('fire_enemy', true);
                    ultimoSparo_enemy = time;
                    this.time.delayedCall(200, () => {
                        if (enemy.flipX){
                            var proiettile_enemy = proiettili_enemy.create(enemy.x-43, enemy.y+15, 'proiettile');
                            proiettile_enemy.setScale(0.5);
                            proiettile_enemy.setSize(9, 5);
                            proiettile_enemy.setOffset(31, 17);
                            proiettile_enemy.flipX = true;
                            proiettile_enemy.setVelocityX(-1500);
                        } else {
                            var proiettile_enemy = proiettili_enemy.create(enemy.x+43, enemy.y+15, 'proiettile');
                            proiettile_enemy.setScale(0.5);
                            proiettile_enemy.setSize(9, 5);
                            proiettile_enemy.setOffset(31, 17);
                            proiettile_enemy.setVelocityX(1500);
                        }
                        proiettile_enemy.body.setAllowGravity(false);
                        
                        proiettile_enemy.setCollideWorldBounds(true);
                    });
                    this.time.delayedCall(enemy.anims.currentAnim.duration, () => {
                            isFiringEnemy = false;
                    });     
            }
        } else if (!nemicoMorto){
            enemy.anims.play('right_enemy', true);
            if (!enemy.flipX){
                enemy.setVelocityX(100);
                if (enemy.body.x >= 590){
                    enemy.anims.play('idle_enemy', true);
                    enemy.setVelocityX(0);
                    this.time.delayedCall(1000, () => {
                        enemy.flipX = true;
                    });
                }
            } else {
                enemy.setVelocityX(-100);
                if (enemy.x <= 300){
                    enemy.anims.play('idle_enemy', true);
                    enemy.setVelocityX(0);
                    this.time.delayedCall(1000, () => {
                        enemy.flipX = false;
                    });
                }
            }
        }
        /*if (ascensore.body.touching.left || ascensore.body.touching.right){
            //ascensore.x = ascensoreX;
            //ascensore.setVelocityX(0);
        }*/
        if (collisione && atterrato){
            //ascensore.setVelocityX(0);
            ascensore.setVelocityY(-100);
            this.time.delayedCall(3000, () => {
                ascensore.setVelocityY(0);
                atterrato = false;
                collisione = false;
            });
        } else if (!atterrato){
            //ascensore.setVelocityX(0);
            ascensore.setVelocityY(100);
            collisione = false;
        }
        if (ammo < 6 && rKey.isDown & player.body.touching.down){
            player.setVelocityX(0);
            player.anims.play('reload', true);
            isReloading = true;
            this.time.delayedCall(player.anims.currentAnim.duration, () => {
                ammo = 6;
                ammoText.setText('Munizioni: ' + ammo);
                isReloading = false;
            });
        } else if (!isReloading && !isGranating){
            if (gKey.isDown && granate > 0  && !isGranatingGo){
                isGranating = true;
                isGranatingGo = true;

                player.setVelocityX(0);
                player.anims.play('grenade', true);
                
                this.time.delayedCall(player.anims.currentAnim.duration, () => {
                    granata.enableBody(true, player.x+20, player.y-50, true, true);
                    if (player.flipX){
                        granata.setVelocity(-500,-50);
                    } else {
                        granata.setVelocity(500,-50);
                    }
                    granata.anims.play('granate_anim', true);
                    this.time.delayedCall(450, () => {

                        granata.setVelocity(0, 0);
                        
                    });
                    this.time.delayedCall(granata.anims.currentAnim.duration, () => {
                        granata.disableBody(true, true);
                        granata.anims.stop();
                        isGranatingGo = false;
                    });
                    isGranating = false;
                });
                granate--;
            } else if (!isGranating){
            
                if (cursors.space.isDown && (time - ultimoSparo) > fireRate && ammo > 0 && !isReloading && player.body.touching.down){
                    player.setVelocityX(0);
                    player.anims.play('fire', true);
                    ultimoSparo = time;
                    isFiring = true;
                    this.time.delayedCall(200, () => {
                        if (player.flipX){
                            var proiettile = proiettili.create(player.x-43, player.y+15, 'proiettile');
                            proiettile.setScale(0.5);
                            proiettile.setSize(9, 5);
                            proiettile.setOffset(31, 17);
                            proiettile.flipX = true;
                            proiettile.setVelocityX(-1500);
                        } else {
                            var proiettile = proiettili.create(player.x+43, player.y+15, 'proiettile');
                            proiettile.setScale(0.5);
                            proiettile.setSize(9, 5);
                            proiettile.setOffset(31, 17);
                            proiettile.setVelocityX(1500);
                        }
                        proiettile.body.setAllowGravity(false);
                        
                        proiettile.setCollideWorldBounds(true);
                        ammo--;
                        ammoText.setText('Munizioni: ' + ammo);
                        if (nemicoMorto){
                            proiettile.disableBody(true, true);
                        }
                        proiettile.body.onWorldBounds = true;
                        this.physics.world.on('worldbounds', function(body) {
                        if (body.gameObject === proiettile) {
                            proiettile.disableBody(true, true);
                        }
                        }, this);
                        });
                        this.time.delayedCall(player.anims.currentAnim.duration, () => {
                            isFiring = false; 
                        });       
                } else if (!isFiring && !isReloading && !isGranating){
                    if (cursors.left.isDown && !(player.body.velocity.x > 0))
                    {
                        if (shiftKey.isDown){
                            player.anims.play('run', true);
                            player.setVelocityX(-250);
                        } else {
                            player.setVelocityX(-160);

                            player.anims.play('left', true);    
                        }
                        player.flipX = true;
                    }
                    else if (cursors.right.isDown)
                    {
                        if (shiftKey.isDown){
                            player.anims.play('run', true);
                            player.setVelocityX(250);
                        } else {
                            player.setVelocityX(160);

                            player.anims.play('right', true);
                        }
                        player.flipX = false;
                    }
                    else
                    {
                        player.setVelocityX(0);

                        player.anims.play('idle', true);
                    }

                    if (cursors.up.isDown && player.body.touching.down)
                    {
                        player.setVelocityY(-330);
                    }
                }
            }
        }
        
    } 
}
function dannoNemico(proiettile){
    nemicoMorto = true;
    enemy.anims.play('death_enemy', true);
    enemy.setVelocityX(0);
    this.time.delayedCall(enemy.anims.currentAnim.duration, () => {
        enemy.disableBody(true, true);
        nemicoMorto = false;
    });
}
function setVariabile(){
    atterrato = true;
    
}
//function ascensoreResta(){
 //   ascensore.x = ascensoreX;
//}
function stop(ascensore, platform){
    ascensore.setVelocity(0);
}

function distanzaPlayerEnemy(){
    return Math.sqrt((player.body.x - enemy.body.x)**2 + (player.body.y - enemy.body.y) ** 2);
}
function ascensoreFunziona(player, ascensore){
    //ascensore.x = ascensoreX;
    if (!atterrato && ascensore.body.touching.down){
        gameOver = true;
    } else {
        collisione = true;
    }
    /*if (atterrato){
        ascensore.setVelocityY(-100);
        this.time.delayedCall(1500, () => {
            ascensore.setVelocityY(0);
            atterrato = false;
        });
    } else{
        ascensore.setVelocityY(100);
        this.time.delayedCall(1500, () => {
            ascensore.setVelocityY(0);
        });
    }*/
}
function collectStar (player, star)
{
    star.disableBody(true, true);
    

    //  Add and update the score
    score += 10;
    scoreText.setText('Score: ' + score);

    if (stars.countActive(true) === 0)
    {
        //  A new batch of stars to collect
        stars.children.iterate(function (child) {

            child.enableBody(true, child.x, 0, true, true);

        });
        var xshield = (player.x < 400) ? Phaser.Math.Between(0, 800) : Phaser.Math.Between(0, 400);
        var shield = shields.create(xshield, 16, 'shield');
        shield.setBounce(0.1);
        var x = (player.x < 400) ? Phaser.Math.Between(400, 800) : Phaser.Math.Between(0, 400);

        var bomb = bombs.create(x, 16, 'bomb');
        bomb.setBounce(1);
        bomb.setCollideWorldBounds(true);
        bomb.setVelocity(Phaser.Math.Between(-200, 200), 20);
        bomb.allowGravity = false;

       

    }
}
function collectLives (player, shield)
{
    shield.disableBody(true, true);

    //  Add and update the score
    lives++;
    livesText.setText('Lives: ' + lives);
}

function hitBomb (player, bomb)
{
    lives = lives -10;
    if (lives>1){
        lives--;
        livesText.setText('lives: ' + lives);
        bomb.disableBody(true, true);

        var x = (player.x < 400) ? Phaser.Math.Between(400, 800) : Phaser.Math.Between(0, 400);

        var bomb = bombs.create(x, 16, 'bomb');
        bomb.setBounce(1);
        bomb.setCollideWorldBounds(true);
        bomb.setVelocity(Phaser.Math.Between(-200, 200), 20);
        bomb.allowGravity = false;
    } else {
        lives--;
        livesText.setText('lives: ' + lives);
        this.physics.pause();

        //player.setTint(0xff0000);

        //player.anims.play('turn');

        gameOver = true;
    }
    
}

</script>

</body>
</html>